#!/usr/bin/env python3
"""
ü§ñ AIM25 INTEL BOT - Discord Bot f√∂r AI-f√∂retag praktikprojektet
================================================================
Automatisk "Dagens AI-f√∂retag" + Pull-baserad s√∂kning

Kommandon:
- /dagens - Dagens AI-f√∂retag
- /sok <namn> - S√∂k efter f√∂retag
- /typ <typ> - Filtrera p√• f√∂retagstyp
- /stad <stad> - Filtrera p√• stad
- /stockholm - F√∂retag i Greater Stockholm
- /help - Visa hj√§lp
"""

import discord
from discord.ext import commands, tasks
import sqlite3
from datetime import datetime, time
import sys
import os
from pathlib import Path
import traceback
from typing import Optional, List, Dict

# Ladda environment variables (om .env finns)
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass  # python-dotenv inte installerad, anv√§nd h√•rdkodade v√§rden

# ==================== DATABAS-HANTERING ====================

class CompanyDatabase:
    """Databas-interface f√∂r AI-f√∂retag"""
    
    def __init__(self, db_path: str = "ai_companies.db"):
        self.db_path = db_path
        self.conn = None
        
    def connect(self):
        """Anslut till databasen"""
        try:
            self.conn = sqlite3.connect(self.db_path)
            self.conn.row_factory = sqlite3.Row
            return True
        except Exception as e:
            print(f"‚ùå Kunde inte ansluta till databas: {e}")
            return False
    
    def close(self):
        """St√§ng databas-anslutning"""
        if self.conn:
            self.conn.close()
    
    def get_random_company(self, only_praktik_relevant: bool = True) -> Optional[Dict]:
        """
        H√§mta ett slumpm√§ssigt f√∂retag
        
        Args:
            only_praktik_relevant: Om True, visa bara praktik-relevanta f√∂retag
        """
        if not self.conn:
            return None
            
        cursor = self.conn.cursor()
        
        where_clause = ""
        if only_praktik_relevant:
            where_clause = "WHERE type IN ('corporation', 'startup', 'supplier')"
        
        query = f"""
        SELECT id, name, website, type, logo_url, description, 
               location_city, location_greater_stockholm
        FROM companies
        {where_clause}
        ORDER BY RANDOM()
        LIMIT 1
        """
        
        cursor.execute(query)
        result = cursor.fetchone()
        
        if result:
            company_id = result['id']
            
            # H√§mta AI-f√∂rm√•gor
            cursor.execute("""
                SELECT ac.name 
                FROM ai_capabilities ac
                JOIN company_ai_capabilities cac ON ac.id = cac.capability_id
                WHERE cac.company_id = ?
                LIMIT 5
            """, (company_id,))
            ai_capabilities = [row['name'] for row in cursor.fetchall()]
            
            return {
                'id': result['id'],
                'name': result['name'],
                'website': result['website'],
                'type': result['type'],
                'logo_url': result['logo_url'],
                'description': result['description'],
                'location_city': result['location_city'],
                'location_greater_stockholm': result['location_greater_stockholm'],
                'ai_capabilities': ai_capabilities
            }
        
        return None
    
    def search_by_name(self, search_term: str, limit: int = 5) -> List[Dict]:
        """S√∂k f√∂retag efter namn"""
        if not self.conn:
            return []
            
        cursor = self.conn.cursor()
        
        query = """
        SELECT id, name, website, type, location_city
        FROM companies
        WHERE name LIKE ?
        ORDER BY name
        LIMIT ?
        """
        
        cursor.execute(query, (f"%{search_term}%", limit))
        
        results = []
        for row in cursor.fetchall():
            results.append({
                'id': row['id'],
                'name': row['name'],
                'website': row['website'],
                'type': row['type'],
                'location_city': row['location_city']
            })
        
        return results
    
    def filter_by_type(self, company_type: str, limit: int = 5) -> List[Dict]:
        """Filtrera f√∂retag p√• typ"""
        if not self.conn:
            return []
            
        cursor = self.conn.cursor()
        
        query = """
        SELECT id, name, website, type, location_city
        FROM companies
        WHERE LOWER(type) = LOWER(?)
        ORDER BY name
        LIMIT ?
        """
        
        cursor.execute(query, (company_type, limit))
        
        results = []
        for row in cursor.fetchall():
            results.append({
                'id': row['id'],
                'name': row['name'],
                'website': row['website'],
                'type': row['type'],
                'location_city': row['location_city']
            })
        
        return results
    
    def filter_by_city(self, city: str, limit: int = 10) -> List[Dict]:
        """Filtrera f√∂retag p√• stad (bara praktik-relevanta)"""
        if not self.conn:
            return []
            
        cursor = self.conn.cursor()
        
        query = """
        SELECT id, name, website, type, description, location_city
        FROM companies
        WHERE location_city LIKE ?
        AND type IN ('corporation', 'startup', 'supplier')
        ORDER BY name
        LIMIT ?
        """
        
        cursor.execute(query, (f"%{city}%", limit))
        
        results = []
        for row in cursor.fetchall():
            results.append({
                'id': row['id'],
                'name': row['name'],
                'website': row['website'],
                'type': row['type'],
                'description': row['description'],
                'location_city': row['location_city']
            })
        
        return results
    
    def filter_greater_stockholm(self, limit: int = 10) -> List[Dict]:
        """Filtrera f√∂retag i Greater Stockholm (bara praktik-relevanta)"""
        if not self.conn:
            return []
            
        cursor = self.conn.cursor()
        
        query = """
        SELECT id, name, website, type, description, location_city
        FROM companies
        WHERE location_greater_stockholm = 1
        AND type IN ('corporation', 'startup', 'supplier')
        ORDER BY name
        LIMIT ?
        """
        
        cursor.execute(query, (limit,))
        
        results = []
        for row in cursor.fetchall():
            results.append({
                'id': row['id'],
                'name': row['name'],
                'website': row['website'],
                'type': row['type'],
                'description': row['description'],
                'location_city': row['location_city']
            })
        
        return results

# ==================== DISCORD BOT ====================

# Bot setup med intents
intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True

bot = commands.Bot(command_prefix='/', intents=intents, help_command=None)

# Global databas-instans
db = CompanyDatabase()

@bot.event
async def on_ready():
    """K√∂rs n√§r botten √§r klar"""
    print(f'\n‚úÖ {bot.user} √§r nu online!')
    print(f'üìä Ansluten till {len(bot.guilds)} server(s)')
    
    # Anslut till databas
    if db.connect():
        print(f'‚úÖ Ansluten till databas: {db.db_path}')
    else:
        print(f'‚ùå Kunde inte ansluta till databas!')
        print(f'‚ö†Ô∏è  Se till att ai_companies.db finns i samma mapp')
    
    # Starta daglig posting (om aktiverad)
    if not daily_company.is_running():
        daily_company.start()
        print('‚úÖ Daglig "Dagens AI-f√∂retag" √§r aktiv')
    
    print(f'\nü§ñ Bot √§r redo att anv√§ndas!')
    print(f'üí° Anv√§nd /help f√∂r att se kommandon\n')

@bot.event
async def on_command_error(ctx, error):
    """Hantera fel i kommandon"""
    if isinstance(error, commands.CommandNotFound):
        await ctx.send("‚ùå Ok√§nt kommando! Anv√§nd `/help` f√∂r att se tillg√§ngliga kommandon.")
    elif isinstance(error, commands.MissingRequiredArgument):
        await ctx.send(f"‚ùå Saknar argument: {error.param.name}")
    else:
        await ctx.send(f"‚ùå Ett fel uppstod: {str(error)}")
        print(f"Fel: {error}")
        traceback.print_exception(type(error), error, error.__traceback__)

# ==================== BOT-KOMMANDON ====================

@bot.command(name='help')
async def help_command(ctx):
    """Visa hj√§lp-meddelande"""
    embed = discord.Embed(
        title="ü§ñ AIM25 Intel Bot - Hj√§lp",
        description="Discord-bot f√∂r att hitta AI-f√∂retag och praktikplatser",
        color=discord.Color.blue()
    )
    
    embed.add_field(
        name="üìã Kommandon",
        value=(
            "`/dagens` - Dagens AI-f√∂retag (slumpm√§ssigt praktik-relevant f√∂retag)\n"
            "`/sok <namn>` - S√∂k efter f√∂retag (t.ex. `/sok Vision`)\n"
            "`/typ <typ>` - Filtrera p√• typ (startup, corporation, supplier)\n"
            "`/stad <stad>` - Hitta f√∂retag i specifik stad\n"
            "`/stockholm` - F√∂retag i Greater Stockholm\n"
            "`/help` - Visa denna hj√§lp"
        ),
        inline=False
    )
    
    embed.add_field(
        name="‚è∞ Automatisk posting",
        value="Botten postar automatiskt 'Dagens AI-f√∂retag' kl 08:00 varje dag",
        inline=False
    )
    
    embed.add_field(
        name="üìä Om datan",
        value="~900+ svenska AI-f√∂retag fr√•n my.ai.se och EU-k√§llor",
        inline=False
    )
    
    embed.set_footer(text="Projekt av ITHS AIM25S | F√∂r praktikjakt üöÄ")
    
    await ctx.send(embed=embed)

@bot.command(name='dagens')
async def dagens(ctx):
    """Dagens AI-f√∂retag - slumpm√§ssigt praktik-relevant f√∂retag"""
    company = db.get_random_company(only_praktik_relevant=True)
    
    if not company:
        await ctx.send("‚ùå Kunde inte hitta n√•got f√∂retag. Kolla att databasen finns!")
        return
    
    # Skapa embed f√∂r snygg presentation
    embed = discord.Embed(
        title=f"üè¢ {company['name']}",
        url=company['website'] if company['website'] else None,
        description=company['description'][:500] + "..." if company.get('description') and len(company.get('description', '')) > 500 else company.get('description', ''),
        color=discord.Color.green()
    )
    
    # L√§gg till f√§lt
    if company.get('website'):
        embed.add_field(name="üåê Hemsida", value=company['website'], inline=False)
    
    if company.get('location_city'):
        location = company['location_city']
        if company.get('location_greater_stockholm'):
            location += " (Greater Stockholm)"
        embed.add_field(name="üìç Plats", value=location, inline=True)
    
    embed.add_field(name="üìä Typ", value=company['type'].capitalize(), inline=True)
    
    if company.get('ai_capabilities'):
        ai_caps = ', '.join(company['ai_capabilities'][:3])
        embed.add_field(name="ü§ñ AI-f√∂rm√•gor", value=ai_caps, inline=False)
    
    # L√§gg till logotyp om den finns
    if company.get('logo_url'):
        embed.set_thumbnail(url=company['logo_url'])
    
    embed.set_footer(text=f"Dagens AI-f√∂retag ‚Ä¢ {datetime.now().strftime('%Y-%m-%d')}")
    
    await ctx.send(embed=embed)

@bot.command(name='sok')
async def sok(ctx, *, search_term: str):
    """
    S√∂k efter f√∂retag
    
    Usage: /sok Vision
    """
    results = db.search_by_name(search_term)
    
    if not results:
        await ctx.send(f"‚ùå Hittade inga f√∂retag som matchar '{search_term}'")
        return
    
    # Skapa embed
    embed = discord.Embed(
        title=f"üîç S√∂kresultat f√∂r '{search_term}'",
        description=f"Hittade {len(results)} f√∂retag",
        color=discord.Color.blue()
    )
    
    for i, company in enumerate(results, 1):
        location = f" - {company['location_city']}" if company.get('location_city') else ""
        value = f"[{company['website']}]({company['website']}){location}\nTyp: {company['type']}"
        embed.add_field(
            name=f"{i}. {company['name']}",
            value=value,
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.command(name='typ')
async def typ(ctx, company_type: str):
    """
    Filtrera f√∂retag p√• typ
    
    Usage: /typ startup
    Typer: startup, corporation, supplier, academia, etc.
    """
    results = db.filter_by_type(company_type)
    
    if not results:
        await ctx.send(f"‚ùå Hittade inga f√∂retag av typ '{company_type}'\nüí° Prova: startup, corporation, supplier")
        return
    
    # Skapa embed
    embed = discord.Embed(
        title=f"üè¢ {company_type.capitalize()}",
        description=f"Visar {len(results)} f√∂retag",
        color=discord.Color.purple()
    )
    
    for company in results:
        location = f" - {company['location_city']}" if company.get('location_city') else ""
        embed.add_field(
            name=company['name'] + location,
            value=f"[{company['website']}]({company['website']})",
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.command(name='stad')
async def stad(ctx, *, city: str):
    """
    Hitta f√∂retag i specifik stad
    
    Usage: /stad Stockholm
    """
    results = db.filter_by_city(city)
    
    if not results:
        await ctx.send(
            f"‚ùå Hittade inga praktik-relevanta f√∂retag i {city}\n"
            f"‚ö†Ô∏è OBS: Endast ~20% av f√∂retagen har location-data (fr√•n EU-k√§lla)"
        )
        return
    
    # Skapa embed
    embed = discord.Embed(
        title=f"üìç AI-f√∂retag i {city}",
        description=f"Hittade {len(results)} praktik-relevanta f√∂retag",
        color=discord.Color.orange()
    )
    
    embed.add_field(
        name="‚ÑπÔ∏è Info",
        value="Endast EU-f√∂retag (~20%) har location-data. my.ai.se-f√∂retag (80%) saknar stad.",
        inline=False
    )
    
    for company in results[:5]:  # Visa max 5
        description = company.get('description', '')[:100] + "..." if company.get('description') else ""
        value = f"[{company['website']}]({company['website']})\n{description}\nTyp: {company['type']}"
        embed.add_field(
            name=company['name'],
            value=value,
            inline=False
        )
    
    if len(results) > 5:
        embed.set_footer(text=f"Visar 5 av {len(results)} f√∂retag")
    
    await ctx.send(embed=embed)

@bot.command(name='stockholm')
async def stockholm(ctx):
    """Visa f√∂retag i Greater Stockholm-omr√•det"""
    results = db.filter_greater_stockholm()
    
    if not results:
        await ctx.send("‚ùå Hittade inga f√∂retag i Greater Stockholm")
        return
    
    # Skapa embed
    embed = discord.Embed(
        title="üèôÔ∏è AI-f√∂retag i Greater Stockholm",
        description=f"Hittade {len(results)} praktik-relevanta f√∂retag",
        color=discord.Color.teal()
    )
    
    for company in results[:5]:  # Visa max 5
        city = company.get('location_city', 'Stockholm')
        description = company.get('description', '')[:100] + "..." if company.get('description') else ""
        value = f"üìç {city}\n[{company['website']}]({company['website']})\n{description}"
        embed.add_field(
            name=f"{company['name']} ({company['type']})",
            value=value,
            inline=False
        )
    
    if len(results) > 5:
        embed.set_footer(text=f"Visar 5 av {len(results)} f√∂retag")
    
    await ctx.send(embed=embed)

# ==================== AUTOMATISK DAGLIG POSTING ====================

@tasks.loop(time=time(hour=8, minute=0))  # K√∂r kl 08:00 varje dag
async def daily_company():
    """
    Posta 'Dagens AI-f√∂retag' automatiskt varje dag kl 08:00
    
    Konfigurera CHANNEL_ID via environment variable eller i .env-fil
    """
    # L√§s channel-ID fr√•n environment variable
    CHANNEL_ID = os.getenv('DAILY_CHANNEL_ID')
    
    if not CHANNEL_ID:
        print("‚ö†Ô∏è  DAILY_CHANNEL_ID √§r inte konfigurerat")
        print("üí° S√§tt DAILY_CHANNEL_ID i .env eller environment variable")
        return
    
    try:
        CHANNEL_ID = int(CHANNEL_ID)
    except ValueError:
        print(f"‚ùå DAILY_CHANNEL_ID √§r inte ett giltigt nummer: {CHANNEL_ID}")
        return
    
    channel = bot.get_channel(CHANNEL_ID)
    if not channel:
        print(f"‚ùå Kunde inte hitta kanal med ID: {CHANNEL_ID}")
        return
    
    # H√§mta dagens f√∂retag
    company = db.get_random_company(only_praktik_relevant=True)
    
    if not company:
        await channel.send("‚ùå Kunde inte hitta dagens f√∂retag")
        return
    
    # Skapa meddelande
    embed = discord.Embed(
        title=f"üåÖ Dagens AI-f√∂retag: {company['name']}",
        url=company['website'] if company['website'] else None,
        description=company['description'][:500] + "..." if company.get('description') and len(company.get('description', '')) > 500 else company.get('description', ''),
        color=discord.Color.gold()
    )
    
    if company.get('website'):
        embed.add_field(name="üåê Hemsida", value=company['website'], inline=False)
    
    if company.get('location_city'):
        location = company['location_city']
        if company.get('location_greater_stockholm'):
            location += " (Greater Stockholm)"
        embed.add_field(name="üìç Plats", value=location, inline=True)
    
    embed.add_field(name="üìä Typ", value=company['type'].capitalize(), inline=True)
    
    if company.get('ai_capabilities'):
        ai_caps = ', '.join(company['ai_capabilities'][:3])
        embed.add_field(name="ü§ñ AI-f√∂rm√•gor", value=ai_caps, inline=False)
    
    if company.get('logo_url'):
        embed.set_thumbnail(url=company['logo_url'])
    
    embed.set_footer(text=f"Dagens AI-f√∂retag ‚Ä¢ {datetime.now().strftime('%Y-%m-%d')} ‚Ä¢ Anv√§nd /help f√∂r fler kommandon")
    
    await channel.send(embed=embed)
    print(f"‚úÖ Postade dagens f√∂retag: {company['name']}")

@daily_company.before_loop
async def before_daily_company():
    """V√§nta tills botten √§r redo innan schemat startar"""
    await bot.wait_until_ready()

# ==================== STARTA BOT ====================

def main():
    """Huvudfunktion - starta botten"""
    
    # L√§s bot token fr√•n environment variable eller anv√§nd h√•rdkodad
    TOKEN = os.getenv('DISCORD_BOT_TOKEN')
        
    if not TOKEN:
        print("‚ùå Bot token saknas!")
        print("üí° S√§tt DISCORD_BOT_TOKEN i .env eller environment variable")
        sys.exit(1)
    
    # L√§s databas-path fr√•n environment variable
    db_path = os.getenv('DATABASE_PATH', 'ai_companies.db')
    
    # Uppdatera global databas-instans
    global db
    db = CompanyDatabase(db_path)
    
    # Kolla att databas finns
    if not Path(db_path).exists():
        print(f"‚ö†Ô∏è  VARNING: {db_path} hittades inte!")
        print("üí° K√∂r 'python build_database.py' f√∂rst f√∂r att skapa databasen")
        print("‚è≥ Botten startar √§nd√•, men kommandon kommer inte fungera...\n")
    
    try:
        print("üöÄ Startar AIM25 Intel Bot...")
        print(f"üìÅ Databas: {db_path}")
        if os.getenv('DISCORD_BOT_TOKEN'):
            print("üîë Anv√§nder token fr√•n environment variable")
        print("‚è≥ Ansluter till Discord...\n")
        bot.run(TOKEN)
    except Exception as e:
        print(f"\n‚ùå Kunde inte starta botten: {e}")
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
